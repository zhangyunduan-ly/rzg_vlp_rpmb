From a6aa68ae17fb467acf9357edd80fbef32f7fcff1 Mon Sep 17 00:00:00 2001
From: hienhuynh <hien.huynh.px@renesas.com>
Date: Fri, 10 May 2024 19:11:25 +0700
Subject: [PATCH 1/4] gpu: drm: bridge: Add ITE it6263 LVDS to HDMI bridge
 driver

The IT6263 is a high-performance single-chip De-SSC LVDS to HDMI
converter. Combined with LVDS receiver and HDMI 1.4a Transmitter,
the IT6263 supports LVDS input and HDMI1.4 output by conversion
function. The build-in LVDS receiver can support single-link and
dual-link LVDS inputs.

Add support for ITE it6263 LVDS to HDMI bridge driver.

Signed-off-by: Biju Das <biju.das.jz@bp.renesas.com>
Signed-off-by: hienhuynh <hien.huynh.px@renesas.com>
---
 drivers/gpu/drm/bridge/Kconfig      |   8 +
 drivers/gpu/drm/bridge/Makefile     |   1 +
 drivers/gpu/drm/bridge/ite-it6263.c | 744 ++++++++++++++++++++++++++++
 3 files changed, 753 insertions(+)
 create mode 100644 drivers/gpu/drm/bridge/ite-it6263.c

diff --git a/drivers/gpu/drm/bridge/Kconfig b/drivers/gpu/drm/bridge/Kconfig
index 12baf9ba03c9..9f30312bb6ce 100644
--- a/drivers/gpu/drm/bridge/Kconfig
+++ b/drivers/gpu/drm/bridge/Kconfig
@@ -380,6 +380,14 @@ config DRM_TI_TPD12S015
 	  Texas Instruments TPD12S015 HDMI level shifter and ESD protection
 	  driver.
 
+config DRM_ITE_IT6263
+	tristate "ITE IT6263 LVDS/HDMI bridge"
+	depends on OF
+	select DRM_KMS_HELPER
+	select REGMAP_I2C
+	help
+	  ITE IT6263 bridge chip driver.
+
 source "drivers/gpu/drm/bridge/analogix/Kconfig"
 
 source "drivers/gpu/drm/bridge/adv7511/Kconfig"
diff --git a/drivers/gpu/drm/bridge/Makefile b/drivers/gpu/drm/bridge/Makefile
index 1884803c6860..8e08284040f3 100644
--- a/drivers/gpu/drm/bridge/Makefile
+++ b/drivers/gpu/drm/bridge/Makefile
@@ -33,6 +33,7 @@ obj-$(CONFIG_DRM_TI_TFP410) += ti-tfp410.o
 obj-$(CONFIG_DRM_TI_TPD12S015) += ti-tpd12s015.o
 obj-$(CONFIG_DRM_NWL_MIPI_DSI) += nwl-dsi.o
 obj-$(CONFIG_DRM_ITE_IT66121) += ite-it66121.o
+obj-$(CONFIG_DRM_ITE_IT6263) += ite-it6263.o
 
 obj-y += analogix/
 obj-y += cadence/
diff --git a/drivers/gpu/drm/bridge/ite-it6263.c b/drivers/gpu/drm/bridge/ite-it6263.c
new file mode 100644
index 000000000000..216e7665f996
--- /dev/null
+++ b/drivers/gpu/drm/bridge/ite-it6263.c
@@ -0,0 +1,744 @@
+// SPDX-License-Identifier: GPL-2.0+
+/*
+ * ITE IT6263 LVDS To HDMI Bridge Driver
+ * Copyright 2017-2019 NXP
+ * Copyright (C) 2024 Renesas Electronics Corp.
+ */
+
+#include <drm/drm_vblank.h>
+#include <drm/drm_bridge.h>
+#include <drm/drm_drv.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_edid.h>
+#include <drm/drm_probe_helper.h>
+#include <drm/drm_print.h>
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/media-bus-format.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_graph.h>
+#include <linux/regmap.h>
+
+/* LVDS registers */
+#define LVDS_REG_SW_RST		0x05
+#define SOFT_PCLK_DM_RST	BIT(1)
+
+#define LVDS_REG_MODE		0x2C
+#define LVDS_COLOR_DEPTH	0x3
+#define LVDS_OUT_MAP		BIT(4)
+#define ITE_LVDS_JEIDA		0
+#define ITE_LVDS_VESA		BIT(4)
+#define DMODE			BIT(7)
+#define SPLIT_MODE		BIT(7)
+#define SINGLE_MODE		0
+
+#define LVDS_REG_PLL		0x3C
+#define LVDS_REG_AFE_3E		0x3E
+#define LVDS_REG_AFE_3F		0x3F
+#define LVDS_REG_AFE_47		0x47
+#define LVDS_REG_AFE_48		0x48
+#define LVDS_REG_AFE_4F		0x4F
+#define LVDS_REG_52		0x52
+#define LVDS_REG_52_PWDB_MASK	GENMASK(1, 0)
+#define LVDS_REG_52_PWDB_LV1	BIT(0)
+#define LVDS_REG_52_PWDB_LV2	BIT(1)
+#define LVDS_REG_52_PWDB_DUAL  (LVDS_REG_52_PWDB_LV1 | LVDS_REG_52_PWDB_LV2)
+
+#define HDMI_REG_SW_RST		0x04
+#define SOFTREF_RST		BIT(5)
+#define SOFTA_RST		BIT(4)
+#define SOFTV_RST		BIT(3)
+#define AUD_RST			BIT(2)
+#define HDCP_RST		BIT(0)
+#define HDMI_RST_ALL		(SOFTREF_RST | SOFTA_RST | SOFTV_RST | \
+				 AUD_RST | HDCP_RST)
+
+#define HDMI_REG_SYS_STATUS	0x0E
+#define HPDETECT		BIT(6)
+#define TXVIDSTABLE		BIT(4)
+
+#define HDMI_REG_BANK_CTRL	0x0F
+#define BANK_SEL(n)		((n) ? 1 : 0)
+
+/* HDMI System DDC control registers */
+#define HDMI_REG_DDC_MASTER_CTRL	0x10
+#define MASTER_SEL_HOST			BIT(0)
+
+#define HDMI_REG_DDC_HEADER		0x11
+#define HDMI_REG_DDC_REQOFF		0x12
+#define HDMI_REG_DDC_REQCOUNT		0x13
+#define HDMI_REG_DDC_EDIDSEG		0x14
+#define HDMI_REG_DDC_CMD		0x15
+#define DDC_CMD_EDID_READ		0x3
+#define DDC_CMD_FIFO_CLR		0x9
+
+#define HDMI_REG_DDC_STATUS		0x16
+#define DDC_DONE			BIT(7)
+#define DDC_ACT				BIT(6)
+#define DDC_NOACK			BIT(5)
+#define DDC_WAITBUS			BIT(4)
+#define DDC_ARBILOSE			BIT(3)
+#define DDC_ERROR			(DDC_NOACK | DDC_WAITBUS | DDC_ARBILOSE)
+#define DDC_FIFOFULL			BIT(2)
+#define DDC_FIFOEMPTY			BIT(1)
+
+#define HDMI_DDC_FIFO_SIZE		32	/* bytes */
+#define HDMI_REG_DDC_READFIFO		0x17
+#define HDMI_REG_LVDS_PORT		0x1D	/* LVDS input ctrl i2c addr */
+#define HDMI_REG_LVDS_PORT_EN		0x1E	/* and to enable */
+#define LVDS_INPUT_CTRL_I2C_ADDR	0x33
+
+/* HDMI AFE registers */
+#define HDMI_REG_AFE_DRV_CTRL		0x61
+#define AFE_DRV_PWD			BIT(5)
+#define AFE_DRV_RST			BIT(4)
+
+#define HDMI_REG_AFE_XP_CTRL		0x62
+#define AFE_XP_GAINBIT			BIT(7)
+#define AFE_XP_ER0			BIT(4)
+#define AFE_XP_RESETB			BIT(3)
+
+#define HDMI_REG_DRV_ISW_CTRL		0x63
+#define HDMI_REG_DRV_ISW_CTRL_VAL	0x10
+
+#define HDMI_REG_AFE_IP_CTRL		0x64
+#define AFE_IP_GAINBIT			BIT(7)
+#define AFE_IP_ER0			BIT(3)
+#define AFE_IP_RESETB			BIT(2)
+
+/* HDMI input data format registers */
+#define HDMI_REG_INPUT_MODE		0x70
+#define IN_RGB				0x00
+
+/* HDMI general control registers */
+#define HDMI_REG_HDMI_MODE		0xC0
+#define TX_HDMI_MODE			1
+
+#define HDMI_REG_GCP			0xC1
+#define AVMUTE				BIT(0)
+#define HDMI_COLOR_DEPTH		0x70
+
+#define HDMI_REG_PKT_GENERAL_CTRL	0xC6
+#define ENABLE_PKT			BIT(0)
+#define REPEAT_PKT			BIT(1)
+
+/* AVI packet registers */
+#define HDMI_REG_AVI_DB1		0x58
+#define AVI_DB1_COLOR_SPACE		0x60
+
+enum {
+	LVDS_COLOR_DEPTH_18,
+	LVDS_COLOR_DEPTH_24,
+	LVDS_COLOR_DEPTH_30,
+	LVDS_COLOR_DEPTH_36,
+};
+
+enum {
+	HDMI_COLOR_DEPTH_DEF = 0x0,	/* default as 24bit */
+	HDMI_COLOR_DEPTH_24  = 0x40,
+	HDMI_COLOR_DEPTH_30  = 0x50,
+	HDMI_COLOR_DEPTH_36  = 0x60,
+	HDMI_COLOR_DEPTH_48  = 0x70,
+};
+
+enum {
+	AVI_COLOR_SPACE_RGB    = 0x00,
+	AVI_COLOR_SPACE_YUV422 = 0x20,
+	AVI_COLOR_SPACE_YUV444 = 0x40,
+};
+
+struct it6263 {
+	struct i2c_client *hdmi_i2c;
+	struct i2c_client *lvds_i2c;
+	struct regmap *hdmi_regmap;
+	struct regmap *lvds_regmap;
+	struct drm_bridge bridge;
+	struct drm_connector connector;
+	struct gpio_desc *reset_gpio;
+	u8 out_map;
+	bool dual_link;
+};
+
+struct it6263_minimode {
+	int hdisplay;
+	int vdisplay;
+	int vrefresh;
+};
+
+static const struct it6263_minimode it6263_bad_mode_db[] = {
+	{1600, 900,  60},
+	{1280, 1024, 60},
+	{1280, 720,  30},
+	{1280, 720,  25},
+	{1280, 720,  24},
+	{1152, 864,  75},
+};
+
+static inline struct it6263 *bridge_to_it6263(struct drm_bridge *bridge)
+{
+	return container_of(bridge, struct it6263, bridge);
+}
+
+static inline struct it6263 *connector_to_it6263(struct drm_connector *con)
+{
+	return container_of(con, struct it6263, connector);
+}
+
+static inline void lvds_update_bits(struct it6263 *it6263, unsigned int reg,
+				    unsigned int mask, unsigned int val)
+{
+	regmap_update_bits(it6263->lvds_regmap, reg, mask, val);
+}
+
+static inline void hdmi_update_bits(struct it6263 *it6263, unsigned int reg,
+				    unsigned int mask, unsigned int val)
+{
+	regmap_update_bits(it6263->hdmi_regmap, reg, mask, val);
+}
+
+static void it6263_reset(struct it6263 *it6263)
+{
+	if (!it6263->reset_gpio)
+		return;
+
+	gpiod_set_value_cansleep(it6263->reset_gpio, 0);
+
+	usleep_range(1000, 2000);
+
+	gpiod_set_value_cansleep(it6263->reset_gpio, 1);
+
+	/*
+	 * The chip maker says the low pulse should be at least 40ms,
+	 * so 41ms is sure to be enough.
+	 */
+	usleep_range(41000, 45000);
+
+	gpiod_set_value_cansleep(it6263->reset_gpio, 0);
+
+	/* somehow, addtional time to wait the high voltage to be stable */
+	usleep_range(5000, 6000);
+}
+
+static void it6263_lvds_reset(struct it6263 *it6263)
+{
+	/* AFE PLL reset */
+	lvds_update_bits(it6263, LVDS_REG_PLL, 0x1, 0x0);
+	usleep_range(1000, 2000);
+	lvds_update_bits(it6263, LVDS_REG_PLL, 0x1, 0x1);
+
+	/* pclk reset */
+	lvds_update_bits(it6263, LVDS_REG_SW_RST, SOFT_PCLK_DM_RST, SOFT_PCLK_DM_RST);
+	usleep_range(1000, 2000);
+	lvds_update_bits(it6263, LVDS_REG_SW_RST, SOFT_PCLK_DM_RST, 0x0);
+
+	usleep_range(1000, 2000);
+}
+
+static void it6263_lvds_set_interface(struct it6263 *it6263)
+{
+	/* color depth */
+	lvds_update_bits(it6263, LVDS_REG_MODE, LVDS_COLOR_DEPTH, LVDS_COLOR_DEPTH_24);
+
+	lvds_update_bits(it6263, LVDS_REG_MODE, LVDS_OUT_MAP, it6263->out_map);
+
+	if (it6263->dual_link) {
+		lvds_update_bits(it6263, LVDS_REG_MODE, DMODE, SPLIT_MODE);
+		lvds_update_bits(it6263, LVDS_REG_52, LVDS_REG_52_PWDB_MASK, LVDS_REG_52_PWDB_DUAL);
+	} else {
+		lvds_update_bits(it6263, LVDS_REG_MODE, DMODE, SINGLE_MODE);
+		lvds_update_bits(it6263, LVDS_REG_52, LVDS_REG_52_PWDB_MASK, LVDS_REG_52_PWDB_LV1);
+	}
+}
+
+static void it6263_lvds_set_afe(struct it6263 *it6263)
+{
+	struct regmap *regmap = it6263->lvds_regmap;
+
+	regmap_write(regmap, LVDS_REG_AFE_3E, 0xaa);
+	regmap_write(regmap, LVDS_REG_AFE_3F, 0x02);
+	regmap_write(regmap, LVDS_REG_AFE_47, 0xaa);
+	regmap_write(regmap, LVDS_REG_AFE_48, 0x02);
+	regmap_write(regmap, LVDS_REG_AFE_4F, 0x11);
+
+	lvds_update_bits(it6263, LVDS_REG_PLL, 0x07, 0);
+}
+
+static void it6263_lvds_config(struct it6263 *it6263)
+{
+	it6263_lvds_reset(it6263);
+	it6263_lvds_set_interface(it6263);
+	it6263_lvds_set_afe(it6263);
+}
+
+static void it6263_hdmi_config(struct it6263 *it6263)
+{
+	regmap_write(it6263->hdmi_regmap, HDMI_REG_INPUT_MODE, IN_RGB);
+
+	hdmi_update_bits(it6263, HDMI_REG_GCP, HDMI_COLOR_DEPTH, HDMI_COLOR_DEPTH_24);
+}
+
+static bool it6263_hpd_is_connected(struct it6263 *it6263)
+{
+	unsigned int status;
+
+	regmap_read(it6263->hdmi_regmap, HDMI_REG_SYS_STATUS, &status);
+
+	return !!(status & HPDETECT);
+}
+
+static enum drm_connector_status
+it6263_connector_detect(struct drm_connector *connector, bool force)
+{
+	struct it6263 *it6263 = connector_to_it6263(connector);
+	int i;
+
+	if (force) {
+		/*
+		 * FIXME: We read status tens of times to workaround
+		 * cable detection failure issue at boot time on some
+		 * platforms.
+		 * Spin on this for up to one second.
+		 */
+		for (i = 0; i < 100; i++) {
+			if (it6263_hpd_is_connected(it6263))
+				return connector_status_connected;
+			usleep_range(5000, 10000);
+		}
+	} else {
+		if (it6263_hpd_is_connected(it6263))
+			return connector_status_connected;
+	}
+
+	return connector_status_disconnected;
+}
+
+static const struct drm_connector_funcs it6263_connector_funcs = {
+	.detect = it6263_connector_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	.destroy = drm_connector_cleanup,
+	.reset = drm_atomic_helper_connector_reset,
+	.atomic_duplicate_state = drm_atomic_helper_connector_duplicate_state,
+	.atomic_destroy_state = drm_atomic_helper_connector_destroy_state,
+};
+
+static int
+it6263_read_edid(void *data, u8 *buf, unsigned int block, size_t len)
+{
+	struct it6263 *it6263 = data;
+	struct regmap *regmap = it6263->hdmi_regmap;
+	unsigned long timeout;
+	unsigned int status, count, val;
+	unsigned int segment = block >> 1;
+	unsigned int start = (block % 2) * EDID_LENGTH;
+
+	regmap_write(regmap, HDMI_REG_DDC_MASTER_CTRL, MASTER_SEL_HOST);
+	regmap_write(regmap, HDMI_REG_DDC_HEADER, DDC_ADDR << 1);
+	regmap_write(regmap, HDMI_REG_DDC_EDIDSEG, segment);
+
+	while (len) {
+		/* clear DDC FIFO */
+		regmap_write(regmap, HDMI_REG_DDC_CMD, DDC_CMD_FIFO_CLR);
+
+		timeout = jiffies + msecs_to_jiffies(10);
+		do {
+			regmap_read(regmap, HDMI_REG_DDC_STATUS, &status);
+		} while (!(status & DDC_DONE) && time_before(jiffies, timeout));
+
+		if (!(status & DDC_DONE)) {
+			dev_err(&it6263->hdmi_i2c->dev, "failed to clear DDC FIFO\n");
+			return -ETIMEDOUT;
+		}
+
+		count = len > HDMI_DDC_FIFO_SIZE ? HDMI_DDC_FIFO_SIZE : len;
+
+		/* fire the read command */
+		regmap_write(regmap, HDMI_REG_DDC_REQOFF, start);
+		regmap_write(regmap, HDMI_REG_DDC_REQCOUNT, count);
+		regmap_write(regmap, HDMI_REG_DDC_CMD, DDC_CMD_EDID_READ);
+
+		start += count;
+		len -= count;
+
+		/* wait for reading done */
+		timeout = jiffies + msecs_to_jiffies(250);
+		do {
+			regmap_read(regmap, HDMI_REG_DDC_STATUS, &status);
+			if (status & DDC_ERROR) {
+				dev_err(&it6263->hdmi_i2c->dev, "DDC error\n");
+				return -EIO;
+			}
+		} while (!(status & DDC_DONE) && time_before(jiffies, timeout));
+
+		if (!(status & DDC_DONE)) {
+			dev_err(&it6263->hdmi_i2c->dev, "EDID read failed\n");
+			return -ETIMEDOUT;
+		}
+
+		/* cache to buffer */
+		for (; count > 0; count--) {
+			regmap_read(regmap, HDMI_REG_DDC_READFIFO, &val);
+			*(buf++) = val;
+		}
+	}
+
+	return 0;
+}
+
+static int it6263_get_modes(struct drm_connector *connector)
+{
+	struct it6263 *it6263 = connector_to_it6263(connector);
+	u32 bus_format = MEDIA_BUS_FMT_RGB888_1X24;
+	struct edid *edid;
+	int num = 0;
+	int ret;
+
+	edid = drm_do_get_edid(connector, it6263_read_edid, it6263);
+	drm_connector_update_edid_property(connector, edid);
+	if (edid) {
+		num = drm_add_edid_modes(connector, edid);
+		kfree(edid);
+	}
+
+	ret = drm_display_info_set_bus_formats(&connector->display_info,
+					       &bus_format, 1);
+	if (ret)
+		dev_dbg(&it6263->hdmi_i2c->dev,
+			"failed to set the supported bus format %d\n", ret);
+
+	return num;
+}
+
+static enum drm_mode_status it6263_mode_valid(struct drm_connector *connector,
+					      struct drm_display_mode *mode)
+{
+	const struct it6263_minimode *m;
+	int i, vrefresh = drm_mode_vrefresh(mode);
+
+	if (mode->clock > 150000)
+		return MODE_CLOCK_HIGH;
+
+	for (i = 0; i < ARRAY_SIZE(it6263_bad_mode_db); i++) {
+		m = &it6263_bad_mode_db[i];
+		if (mode->hdisplay == m->hdisplay &&
+		    mode->vdisplay == m->vdisplay &&
+		    vrefresh == m->vrefresh)
+			return MODE_BAD;
+	}
+
+	return MODE_OK;
+}
+
+static const struct drm_connector_helper_funcs it6263_connector_helper_funcs = {
+	.get_modes = it6263_get_modes,
+	.mode_valid = it6263_mode_valid,
+};
+
+static void it6263_bridge_disable(struct drm_bridge *bridge)
+{
+	struct it6263 *it6263 = bridge_to_it6263(bridge);
+	struct regmap *regmap = it6263->hdmi_regmap;
+
+	/* AV mute */
+	hdmi_update_bits(it6263, HDMI_REG_GCP, AVMUTE, AVMUTE);
+
+	regmap_write(regmap, HDMI_REG_PKT_GENERAL_CTRL, 0);
+
+	hdmi_update_bits(it6263, HDMI_REG_SW_RST, SOFTV_RST, SOFTV_RST);
+	regmap_write(regmap, HDMI_REG_AFE_DRV_CTRL, AFE_DRV_RST | AFE_DRV_PWD);
+}
+
+static void it6263_bridge_enable(struct drm_bridge *bridge)
+{
+	struct it6263 *it6263 = bridge_to_it6263(bridge);
+	struct regmap *regmap = it6263->hdmi_regmap;
+	bool is_stable = false;
+	unsigned long timeout;
+	unsigned int status;
+	int i;
+
+	regmap_write(it6263->hdmi_regmap, HDMI_REG_BANK_CTRL, BANK_SEL(1));
+	/* Set the color space to RGB in the AVI packet */
+	hdmi_update_bits(it6263, HDMI_REG_AVI_DB1, AVI_DB1_COLOR_SPACE,
+			 AVI_COLOR_SPACE_RGB);
+	regmap_write(it6263->hdmi_regmap, HDMI_REG_BANK_CTRL, BANK_SEL(0));
+
+	/* Software video reset */
+	hdmi_update_bits(it6263, HDMI_REG_SW_RST, SOFTV_RST, SOFTV_RST);
+	usleep_range(1000, 2000);
+	hdmi_update_bits(it6263, HDMI_REG_SW_RST, SOFTV_RST, 0);
+
+	/* Reconfigure LVDS and retry several times in case video is instable */
+	for (i = 0; i < 3; i++) {
+		timeout = jiffies + msecs_to_jiffies(500);
+		do {
+			regmap_read(regmap, HDMI_REG_SYS_STATUS, &status);
+		} while (!(status & TXVIDSTABLE) && time_before(jiffies, timeout));
+
+		if (status & TXVIDSTABLE) {
+			is_stable = true;
+			break;
+		}
+
+		it6263_lvds_config(it6263);
+	}
+
+	if (!is_stable)
+		dev_warn(&it6263->hdmi_i2c->dev, "failed to wait for video stable\n");
+
+	regmap_write(regmap, HDMI_REG_AFE_DRV_CTRL, 0);
+
+	/* AV unmute */
+	hdmi_update_bits(it6263, HDMI_REG_GCP, AVMUTE, 0);
+
+	regmap_write(regmap, HDMI_REG_PKT_GENERAL_CTRL, ENABLE_PKT | REPEAT_PKT);
+}
+
+static void it6263_bridge_mode_set(struct drm_bridge *bridge,
+				   const struct drm_display_mode *mode,
+				   const struct drm_display_mode *adj)
+{
+	bool pclk_high = adj->clock > 80000 ? true : false;
+	struct it6263 *it6263 = bridge_to_it6263(bridge);
+	struct regmap *regmap = it6263->hdmi_regmap;
+
+	regmap_write(regmap, HDMI_REG_HDMI_MODE, TX_HDMI_MODE);
+
+	/* Setup AFE */
+	regmap_write(regmap, HDMI_REG_AFE_DRV_CTRL, AFE_DRV_RST);
+	if (pclk_high)
+		regmap_write(regmap, HDMI_REG_AFE_XP_CTRL, AFE_XP_GAINBIT | AFE_XP_RESETB);
+	else
+		regmap_write(regmap, HDMI_REG_AFE_XP_CTRL, AFE_XP_ER0 | AFE_XP_RESETB);
+	regmap_write(regmap, HDMI_REG_DRV_ISW_CTRL, HDMI_REG_DRV_ISW_CTRL_VAL);
+	if (pclk_high)
+		regmap_write(regmap, HDMI_REG_AFE_IP_CTRL, AFE_IP_GAINBIT | AFE_IP_RESETB);
+	else
+		regmap_write(regmap, HDMI_REG_AFE_IP_CTRL, AFE_IP_ER0 | AFE_IP_RESETB);
+}
+
+static int it6263_bridge_attach(struct drm_bridge *bridge,
+				enum drm_bridge_attach_flags flags)
+{
+	struct it6263 *it6263 = bridge_to_it6263(bridge);
+	struct drm_device *drm = bridge->dev;
+	int ret;
+
+	if (!drm_core_check_feature(drm, DRIVER_ATOMIC)) {
+		dev_err(&it6263->hdmi_i2c->dev,
+			"it6263 driver only copes with atomic updates\n");
+		return -EOPNOTSUPP;
+	}
+
+	if (!(flags & DRM_BRIDGE_ATTACH_NO_CONNECTOR)) {
+		it6263->connector.polled = DRM_CONNECTOR_POLL_CONNECT |
+					DRM_CONNECTOR_POLL_DISCONNECT;
+		ret = drm_connector_init(drm, &it6263->connector,
+					 &it6263_connector_funcs,
+					 DRM_MODE_CONNECTOR_HDMIA);
+		if (ret) {
+			dev_err(&it6263->hdmi_i2c->dev,
+				"Failed to initialize connector with drm\n");
+			return ret;
+		}
+
+		drm_connector_helper_add(&it6263->connector,
+					 &it6263_connector_helper_funcs);
+		drm_connector_attach_encoder(&it6263->connector, bridge->encoder);
+	}
+
+	return 0;
+}
+
+static struct edid *it6263_bridge_get_edid(struct drm_bridge *bridge,
+					   struct drm_connector *connector)
+{
+	struct it6263 *it6263 = bridge_to_it6263(bridge);
+
+	return drm_do_get_edid(connector, it6263_read_edid, it6263);
+}
+
+static enum drm_connector_status it6263_bridge_detect(struct drm_bridge *bridge)
+{
+	struct it6263 *it6263 = bridge_to_it6263(bridge);
+
+	if (it6263_hpd_is_connected(it6263))
+		return connector_status_connected;
+
+	return connector_status_disconnected;
+}
+
+static const struct drm_bridge_funcs it6263_bridge_funcs = {
+	.attach = it6263_bridge_attach,
+	.mode_set = it6263_bridge_mode_set,
+	.disable = it6263_bridge_disable,
+	.enable = it6263_bridge_enable,
+	.get_edid = it6263_bridge_get_edid,
+	.detect = it6263_bridge_detect,
+};
+
+static const struct regmap_range it6263_hdmi_volatile_ranges[] = {
+	{ .range_min = 0, .range_max = 0x1ff },
+};
+
+static const struct regmap_access_table it6263_hdmi_volatile_table = {
+	.yes_ranges = it6263_hdmi_volatile_ranges,
+	.n_yes_ranges = ARRAY_SIZE(it6263_hdmi_volatile_ranges),
+};
+
+static const struct regmap_config it6263_hdmi_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.volatile_table = &it6263_hdmi_volatile_table,
+	.cache_type = REGCACHE_NONE,
+};
+
+static const struct regmap_range it6263_lvds_volatile_ranges[] = {
+	{ .range_min = 0, .range_max = 0xff },
+};
+
+static const struct regmap_access_table it6263_lvds_volatile_table = {
+	.yes_ranges = it6263_lvds_volatile_ranges,
+	.n_yes_ranges = ARRAY_SIZE(it6263_lvds_volatile_ranges),
+};
+
+static const struct regmap_config it6263_lvds_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.volatile_table = &it6263_lvds_volatile_table,
+	.cache_type = REGCACHE_NONE,
+};
+
+static inline u8 it6263_out_map(struct device_node *np)
+{
+	u8 ret = ITE_LVDS_VESA;
+	const char *name;
+
+	if (!of_property_read_string(np, "ite,data-mapping", &name) &&
+	    (strncmp(name, "jeida", 5) == 0))
+		ret = ITE_LVDS_JEIDA;
+
+	return ret;
+}
+
+static int it6263_probe(struct i2c_client *client,
+			const struct i2c_device_id *id)
+{
+	struct device *dev = &client->dev;
+	struct device_node *np = dev->of_node;
+	struct it6263 *it6263;
+	int ret;
+
+	it6263 = devm_kzalloc(dev, sizeof(*it6263), GFP_KERNEL);
+	if (!it6263)
+		return -ENOMEM;
+
+	it6263->dual_link = of_property_read_bool(np, "ite,dual-link");
+	it6263->out_map = it6263_out_map(np);
+
+	it6263->hdmi_i2c = client;
+	it6263->lvds_i2c = i2c_new_dummy_device(client->adapter,
+						LVDS_INPUT_CTRL_I2C_ADDR);
+	if (!it6263->lvds_i2c)
+		return -ENODEV;
+
+	it6263->hdmi_regmap = devm_regmap_init_i2c(client,
+						   &it6263_hdmi_regmap_config);
+	if (IS_ERR(it6263->hdmi_regmap)) {
+		ret = PTR_ERR(it6263->hdmi_regmap);
+		goto unregister_lvds_i2c;
+	}
+
+	it6263->lvds_regmap = devm_regmap_init_i2c(it6263->lvds_i2c,
+						   &it6263_lvds_regmap_config);
+	if (IS_ERR(it6263->lvds_regmap)) {
+		ret = PTR_ERR(it6263->lvds_regmap);
+		goto unregister_lvds_i2c;
+	}
+
+	it6263->reset_gpio = devm_gpiod_get_optional(dev, "reset",
+						     GPIOD_OUT_LOW);
+	if (IS_ERR(it6263->reset_gpio)) {
+		ret = PTR_ERR(it6263->reset_gpio);
+		if (ret != -EPROBE_DEFER)
+			dev_err_probe(dev, ret, "Failed to get reset gpio\n");
+
+		goto unregister_lvds_i2c;
+	}
+
+	it6263_reset(it6263);
+
+	ret = regmap_write(it6263->hdmi_regmap, HDMI_REG_SW_RST, HDMI_RST_ALL);
+	if (ret)
+		goto unregister_lvds_i2c;
+
+	usleep_range(1000, 2000);
+
+	ret = regmap_write(it6263->hdmi_regmap, HDMI_REG_LVDS_PORT,
+			   LVDS_INPUT_CTRL_I2C_ADDR << 1);
+	if (ret)
+		goto unregister_lvds_i2c;
+
+	ret = regmap_write(it6263->hdmi_regmap, HDMI_REG_LVDS_PORT_EN, 0x01);
+	if (ret)
+		goto unregister_lvds_i2c;
+
+	/* select HDMI bank0 */
+	ret = regmap_write(it6263->hdmi_regmap, HDMI_REG_BANK_CTRL, BANK_SEL(0));
+	if (ret)
+		goto unregister_lvds_i2c;
+
+	it6263_lvds_config(it6263);
+	it6263_hdmi_config(it6263);
+
+	it6263->bridge.funcs = &it6263_bridge_funcs;
+	it6263->bridge.of_node = np;
+	it6263->bridge.ops = DRM_BRIDGE_OP_DETECT | DRM_BRIDGE_OP_EDID;
+	it6263->bridge.type = DRM_MODE_CONNECTOR_HDMIA;
+	drm_bridge_add(&it6263->bridge);
+
+	i2c_set_clientdata(client, it6263);
+
+	return 0;
+
+unregister_lvds_i2c:
+	i2c_unregister_device(it6263->lvds_i2c);
+
+	return ret;
+}
+
+static void it6263_remove(struct i2c_client *client)
+{
+	struct it6263 *it6263 = i2c_get_clientdata(client);
+
+	drm_bridge_remove(&it6263->bridge);
+	i2c_unregister_device(it6263->lvds_i2c);
+}
+
+static const struct of_device_id it6263_dt_ids[] = {
+	{ .compatible = "ite,it6263" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, it6263_dt_ids);
+
+static const struct i2c_device_id it6263_i2c_ids[] = {
+	{ "it6263", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, it6263_i2c_ids);
+
+static struct i2c_driver it6263_driver = {
+	.driver = {
+		.name = "it6263",
+		.of_match_table = it6263_dt_ids,
+	},
+	.probe = it6263_probe,
+	.remove = it6263_remove,
+	.id_table = it6263_i2c_ids,
+};
+module_i2c_driver(it6263_driver);
+
+MODULE_AUTHOR("Biju Das <biju.das@bp.renesas.com>");
+MODULE_DESCRIPTION("ITE IT6263 LVDS->HDMI Bridge driver");
+MODULE_LICENSE("GPL");
-- 
2.25.1

